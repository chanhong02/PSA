import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

# 1. 파라미터 및 상수
Rg = 8.314
T = 300.15
eps = 0.32
DL = 9e-7
KA = 9.35
kA = 0.0832
KB = 9.35
kB = 0.00468
PH = 950000      # Pa
PL = 101325      # Pa
tfp = 40         # s
column_length = 2.5  # m
yA_feed = 0.21   # 공급 가스 내 A 성분 몰분율

N = 11
delta_z = column_length / (N - 1)

# ★★★ 중요: 행렬을 논문에서 제공된 원본으로 복원합니다 ★★★
Matrix_A = np.array([
    [-9.1602, 14.96, -10.336, 8.3222, -7.0296, 6.0402, -5.1923, 4.3967, -3.5791, 2.632, -1.0543],
    [-2.9225, -4.0248, 10.913, -6.9352, 5.3886, -4.4499, 3.7429, -3.1292, 2.528, -1.8512, 0.74031],
    [0.88657, -4.7918, -2.6072, 9.9843, -5.9667, 4.4664, -3.5791, 2.9127, -2.3168, 1.6823, -0.67052],
    [-0.43165, 1.8414, -6.0373, -1.9568, 9.9317, -5.6682, 4.0959, -3.1667, 2.4498, -1.753, 0.69475],
    [0.26641, -1.0454, 2.6363, -7.257, -1.5918, 10.418, -5.7238, 3.9871, -2.933, 2.0468, -0.80363],
    [-0.19229, 0.72519, -1.6577, 3.479, -8.7513, -1.365, 11.448, -6.0685, 4.0333, -2.6903, 1.0394],
    [0.15681, -0.57866, 1.2602, -2.3849, 4.5612, -10.86, -1.2163, 13.232, -6.7274, 4.0901, -1.5331],
    [-0.14276, 0.52014, -1.1026, 1.9825, -3.4161, 6.1897, -14.227, -1.1174, 16.312, -7.6987, 2.7006],
    [0.14633, -0.52909, 1.1043, -1.9311, 3.1641, -5.1796, 9.1072, -20.538, -1.0531, 22.03, -6.3204],
    [-0.17802, 0.64096, -1.3265, 2.2859, -3.6528, 5.7158, -9.16, 16.036, -36.445, -1.0154, 27.099],
    [0.42424, -1.5249, 3.1455, -5.3899, 8.5325, -13.137, 20.427, -33.466, 62.207, -161.22, 120]
])

Matrix_B = np.array([
    [-23.43, -5.8982, 61.295, -61.652, 56.372, -50.304, 44.148, -37.841, 31.029, -22.91, 9.1916],
    [70.069, -144.95, 83.106, -6.6484, -5.6013, 8.5995, -9.0083, 8.3874, -7.1837, 5.4251, -2.1954],
    [-12.372, 98.598, -177.83, 108.28, -21.426, 5.9422, -1.0519, -0.7598, 1.33, -1.2495, 0.54203],
    [4.3848, -22.477, 120.02, -211.98, 132.66, -30.953, 12.171, -5.7949, 3.0242, -1.6252, 0.56268],
    [-2.1733, 9.5551, -30.959, 148.17, -262.28, 167.64, -42.018, 18.31, -9.8658, 5.6814, -2.0566],
    [1.3362, -5.4638, 14.731, -41.745, 192.42, -345.15, 225.38, -59.019, 26.879, -14.526, 5.1562],
    [-0.96735, 3.8021, -9.3693, 21.81, -58.871, 269.78, -495.39, 331.94, -89.812, 40.772, -13.694],
    [0.80723, -3.1, 7.2688, -15.363, 33.914, -90.774, 423.24, -808.55, 561.48, -154.48, 45.56],
    [-0.96735, 2.9497, -6.7215, 13.485, -27.033, 59.36, -162.81, 796.07, -1639.6, 1202.6, -237.59],
    [0.91276, -3.431, 7.6977, -15.026, 28.721, -57.778, 132.03, -390.11, 2140.3, -5370.9, 3527.5],
    [100.52, -361.01, 743.31, -1269.8, 2000, -3052.7, 4670.8, -7392.8, 12460, -17378, 9480]
])


import numpy as np

A = Matrix_A   # 논문/원본 행렬
B = Matrix_B
N = A.shape[0]

def check_last_row_is_only_last_two(M, trials=500, tol=1e-10):
    # 무작위 y들을 만들어서 M[-1] @ y 가 항상 α*y[-2]+β*y[-1] 형식인지 확인
    Ys = np.random.randn(trials, N)
    lhs = Ys @ M[-1,:].T                       # shape (trials,)
    R = Ys[:,[-2,-1]]                          # columns: y_{N-2}, y_{N-1}
    # 최소제곱으로 α,β 적합
    coeff, *_ = np.linalg.lstsq(R, lhs, rcond=None)
    resid = lhs - R @ coeff                    # 잔차
    return coeff, np.max(np.abs(resid))

coef_A, max_err_A = check_last_row_is_only_last_two(A)
coef_B, max_err_B = check_last_row_is_only_last_two(B)
print("A last row ~ α*y[N-2]+β*y[N-1] ?  α,β=", coef_A, "  max residual=", max_err_A)
print("B last row ~ α*y[N-2]+β*y[N-1] ?  α,β=", coef_B, "  max residual=", max_err_B)